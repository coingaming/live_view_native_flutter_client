import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:xml/xml.dart';

/// Default icon data and icon widget constants.
const IconData defaultIconData = Icons.crop_square_sharp;
const Icon defaultIcon = Icon(defaultIconData);

/// Extension on [XmlNode] to provide utility methods for XML node manipulation.
extension NonEmptyChildren on XmlNode {
  /// Returns a list of non-empty child nodes.
  List<XmlNode> get nonEmptyChildren {
    return children.where((XmlNode c) => !c.isEmpty).toList();
  }

  /// Checks if the node is empty.
  /// A node is considered empty if it is a text node with no content or only whitespace.
  bool get isEmpty =>
      nodeType == XmlNodeType.TEXT && (value ?? '').trim().isEmpty;
}

/// Extension on [List<String>] to provide a method for joining strings with custom separators.
extension JoinMethod on List<String> {
  /// Joins the list of strings with a separator generated by the provided function.
  ///
  /// The [separator] function takes the index of the string and returns a separator string.
  String joinWith(String Function(int index) separator) {
    int index = -1;
    Iterator<String> iterator = this.iterator;

    if (!iterator.moveNext()) return "";
    String first = iterator.current.toString();

    if (!iterator.moveNext()) return first;
    StringBuffer buffer = StringBuffer(first);

    if (separator(index++).isEmpty) {
      do {
        buffer.write(iterator.current.toString());
      } while (iterator.moveNext());
    } else {
      do {
        buffer
          ..write(separator(index++))
          ..write(iterator.current.toString());
      } while (iterator.moveNext());
    }

    return buffer.toString();
  }
}

/// Extension on [String] to provide a method for matching against regular expressions.
extension Matches on String {
  /// Returns true if the string matches the provided [regex].
  bool matches(String regex) => RegExp(regex).hasMatch(this);
}

/// Attempts to decode a JSON string and returns the result.
///
/// If the decoding fails, returns null instead of throwing an exception.
/// Optionally accepts a [reviver] function for custom decoding.
dynamic tryJsonDecode(String? source,
    {Object? Function(Object?, Object?)? reviver}) {
  if (source == null) return null;

  try {
    return jsonDecode(source, reviver: reviver);
  } on FormatException {
    return null;
  }
}

/// Extension on [ThemeMode] to provide string parsing and conversion.
extension ThemeModeStringify on ThemeMode {
  /// Parses a string to return the corresponding [ThemeMode].
  ///
  /// Supported values are 'light', 'dark', and 'system'. Defaults to 'system'.
  static ThemeMode parse(String mode) {
    return switch (mode) {
      'light' => ThemeMode.light,
      'dark' => ThemeMode.dark,
      _ => ThemeMode.system,
    };
  }

  /// Converts the current [ThemeMode] to a string.
  String modeAsString() {
    return switch (this) {
      ThemeMode.light => 'light',
      ThemeMode.dark => 'dark',
      _ => 'system',
    };
  }
}

/// Reports an error in debug mode by throwing an exception or printing the error in release mode.
void reportError(String error) {
  if (kDebugMode) {
    throw Exception(error);
  } else {
    debugPrint(error);
  }
}
